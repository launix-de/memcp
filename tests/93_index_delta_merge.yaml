# Tests for non-unique index delta+main streaming merge
# Exercises StorageIndex.iterate() where main items (StorageInt) and
# delta items (deltaBtree) are interleaved in sorted order.
# Pattern: CREATE, INSERT, (rebuild), trigger index build, INSERT more, SELECT
# Also includes a matrix multiplication correctness test via equi join.

metadata:
  version: "1.0"
  description: "Non-unique index: delta+main streaming merge, matrix multiply"

test_cases:
  # ==============================================================
  # Phase 1: Setup — populate main, build non-unique index
  # ==============================================================

  - name: "Setup: create table"
    setup:
      - sql: "DROP TABLE IF EXISTS idx_merge"
      - sql: "DROP TABLE IF EXISTS idx_dim"
      - sql: "DROP TABLE IF EXISTS mat_a"
      - sql: "DROP TABLE IF EXISTS mat_b"
      - sql: "DROP TABLE IF EXISTS mat_c"
      - scm: "(rebuild)"
    sql: "CREATE TABLE idx_merge (id INT PRIMARY KEY, cat INT, val INT)"

  - name: "Insert 200 rows and rebuild to main"
    setup:
      - scm: |
          (begin
            (insert "memcp-tests" "idx_merge" '("id" "cat" "val")
              (map (produceN 200) (lambda (i) (list i (- i (* 10 (floor (/ i 10)))) (* i 7)))))
            (rebuild))
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge"
    expect:
      data:
        - cnt: 200

  # Two queries on cat trigger lazy index build (Savings threshold = 2.0)
  - name: "Index warmup 1 (Savings=1)"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 3"
    expect:
      data:
        - cnt: 20

  - name: "Index warmup 2 (Savings=2, index built)"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 7"
    expect:
      data:
        - cnt: 20

  # ==============================================================
  # Phase 2: Insert delta rows, test streaming merge
  # ==============================================================

  - name: "Insert delta rows interleaving with main"
    sql: "INSERT INTO idx_merge VALUES (200, 3, 1400), (201, 3, 1407), (202, 5, 1414), (203, 7, 1421), (204, 0, 1428)"
    expect:
      affected_rows: 5

  # Narrow range at boundary: main ids end at 193 for cat=3, delta adds 200,201
  - name: "Merge boundary: high-id main + delta in cat=3"
    sql: "SELECT id FROM idx_merge WHERE cat = 3 AND id >= 190 ORDER BY id"
    expect:
      data:
        - id: 193
        - id: 200
        - id: 201

  - name: "Merge count: cat=3 (20 main + 2 delta)"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 3"
    expect:
      data:
        - cnt: 22

  - name: "Merge count: cat range 3-5 (60 main + 3 delta)"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat >= 3 AND cat <= 5"
    expect:
      data:
        - cnt: 63

  - name: "Merge count: all cats (200 main + 5 delta)"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat >= 0 AND cat <= 9"
    expect:
      data:
        - cnt: 205

  # ==============================================================
  # Phase 3: Delete + merge
  # ==============================================================

  - name: "Delete main rows in cat=3"
    sql: "DELETE FROM idx_merge WHERE id IN (3, 13, 23)"
    expect:
      affected_rows: 3

  - name: "Post-delete count: cat=3"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 3"
    expect:
      data:
        - cnt: 19

  - name: "Post-delete boundary check"
    sql: "SELECT id FROM idx_merge WHERE cat = 3 AND id <= 40 ORDER BY id"
    expect:
      data:
        - id: 33

  # ==============================================================
  # Phase 4: Join with delta+main inner side
  # ==============================================================

  - name: "Create dimension table"
    sql: "CREATE TABLE idx_dim (cat_id INT PRIMARY KEY, label TEXT)"

  - name: "Populate dimension"
    sql: "INSERT INTO idx_dim VALUES (3, 'three'), (5, 'five'), (7, 'seven')"

  # GROUP BY on joins not yet supported — verify join correctness via delta rows
  - name: "Join: delta rows visible on inner side"
    sql: "SELECT d.label, m.id FROM idx_dim d JOIN idx_merge m ON m.cat = d.cat_id WHERE m.id >= 200 ORDER BY d.label, m.id"
    expect:
      data:
        - label: "five"
          id: 202
        - label: "seven"
          id: 203
        - label: "three"
          id: 200
        - label: "three"
          id: 201

  # ==============================================================
  # Phase 5: Rebuild with mixed data, verify merge survives
  # ==============================================================

  - name: "Rebuild mixed main+delta"
    scm: "(rebuild)"

  - name: "Post-rebuild: total count still correct"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge"
    expect:
      data:
        - cnt: 202

  - name: "Post-rebuild: insert new delta"
    sql: "INSERT INTO idx_merge VALUES (300, 3, 2100), (301, 5, 2107)"
    expect:
      affected_rows: 2

  # Need 2 queries to rebuild index after rebuild discards it
  - name: "Post-rebuild index warmup 1"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 0"
    expect:
      data:
        - cnt: 21

  - name: "Post-rebuild index warmup 2"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 0"
    expect:
      data:
        - cnt: 21

  - name: "Post-rebuild merge: new delta included"
    sql: "SELECT COUNT(*) AS cnt FROM idx_merge WHERE cat = 3"
    expect:
      data:
        - cnt: 20

  # ==============================================================
  # Phase 6: Matrix multiplication correctness (3x3 x 3x3)
  # Uses INSERT...SELECT to materialize join, then GROUP BY on single table
  # ==============================================================

  - name: "Create matrix A"
    sql: "CREATE TABLE mat_a (r INT, c INT, v INT)"

  - name: "Create matrix B"
    sql: "CREATE TABLE mat_b (r INT, c INT, v INT)"

  - name: "Create result table"
    sql: "CREATE TABLE mat_c (r INT, c INT, v INT)"

  - name: "Populate A = [[1,2,3],[4,5,6],[7,8,9]]"
    sql: "INSERT INTO mat_a VALUES (0,0,1),(0,1,2),(0,2,3),(1,0,4),(1,1,5),(1,2,6),(2,0,7),(2,1,8),(2,2,9)"

  - name: "Populate B = [[9,8,7],[6,5,4],[3,2,1]]"
    sql: "INSERT INTO mat_b VALUES (0,0,9),(0,1,8),(0,2,7),(1,0,6),(1,1,5),(1,2,4),(2,0,3),(2,1,2),(2,2,1)"

  - name: "Materialize join: C_flat = A.v * B.v for matching A.c = B.r"
    sql: "INSERT INTO mat_c (r, c, v) SELECT a.r, b.c, a.v * b.v FROM mat_a a JOIN mat_b b ON a.c = b.r"
    expect:
      affected_rows: 27

  - name: "Matrix multiply C = A*B via SUM on materialized join"
    sql: "SELECT r, c, SUM(v) AS v FROM mat_c GROUP BY r, c ORDER BY r, c"
    expect:
      data:
        - r: 0
          c: 0
          v: 30
        - r: 0
          c: 1
          v: 24
        - r: 0
          c: 2
          v: 18
        - r: 1
          c: 0
          v: 84
        - r: 1
          c: 1
          v: 69
        - r: 1
          c: 2
          v: 54
        - r: 2
          c: 0
          v: 138
        - r: 2
          c: 1
          v: 114
        - r: 2
          c: 2
          v: 90

  # Verify with delta: rebuild, insert extra row into A, redo multiply
  - name: "Rebuild matrices to main"
    scm: "(rebuild)"

  - name: "Insert delta row into A: row 3 = [1,1,1]"
    sql: "INSERT INTO mat_a VALUES (3,0,1),(3,1,1),(3,2,1)"

  - name: "Recreate result table for delta test"
    setup:
      - sql: "DROP TABLE IF EXISTS mat_c"
    sql: "CREATE TABLE mat_c (r INT, c INT, v INT)"

  - name: "Join with delta row: [1,1,1] * B row 0"
    sql: "SELECT a.r, b.c, a.v * b.v AS v FROM mat_a a JOIN mat_b b ON a.c = b.r WHERE a.r = 3 AND b.c = 0 ORDER BY a.c"
    expect:
      data:
        - r: 3
          c: 0
          v: 9
        - r: 3
          c: 0
          v: 6
        - r: 3
          c: 0
          v: 3

  # ==============================================================
  # Phase 7: GROUP BY on joined tables (prejoins)
  # ==============================================================

  - name: "Matrix multiply via direct GROUP BY on join"
    sql: "SELECT a.r, b.c, SUM(a.v * b.v) AS v FROM mat_a a JOIN mat_b b ON a.c = b.r GROUP BY a.r, b.c ORDER BY a.r, b.c"
    expect:
      data:
        - r: 0
          c: 0
          v: 30
        - r: 0
          c: 1
          v: 24
        - r: 0
          c: 2
          v: 18
        - r: 1
          c: 0
          v: 84
        - r: 1
          c: 1
          v: 69
        - r: 1
          c: 2
          v: 54
        - r: 2
          c: 0
          v: 138
        - r: 2
          c: 1
          v: 114
        - r: 2
          c: 2
          v: 90
        - r: 3
          c: 0
          v: 18
        - r: 3
          c: 1
          v: 15
        - r: 3
          c: 2
          v: 12

  - name: "COUNT with GROUP BY on join"
    sql: "SELECT d.label, COUNT(*) AS cnt FROM idx_dim d JOIN idx_merge m ON m.cat = d.cat_id GROUP BY d.label ORDER BY d.label"
    expect:
      data:
        - label: "five"
          cnt: 22
        - label: "seven"
          cnt: 21
        - label: "three"
          cnt: 20

  - name: "GROUP BY join with HAVING"
    sql: "SELECT a.r, SUM(a.v * b.v) AS total FROM mat_a a JOIN mat_b b ON a.c = b.r GROUP BY a.r HAVING SUM(a.v * b.v) > 100 ORDER BY a.r"
    expect:
      data:
        - r: 1
          total: 207
        - r: 2
          total: 342

cleanup:
  - sql: "DROP TABLE IF EXISTS idx_merge"
  - sql: "DROP TABLE IF EXISTS idx_dim"
  - sql: "DROP TABLE IF EXISTS mat_a"
  - sql: "DROP TABLE IF EXISTS mat_b"
  - sql: "DROP TABLE IF EXISTS mat_c"
