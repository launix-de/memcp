metadata:
  version: "1.0"
  description: "Memory pressure management"

setup:
  - sql: "DROP TABLE IF EXISTS mp_pressure"
  - sql: "CREATE TABLE mp_pressure (id INT, a INT, b INT, c INT, d INT, e INT, f TEXT)"

test_cases:
  - name: "MP: insert 300k rows and rebuild"
    scm: |
      (begin
        (set imod (lambda (a b) (- a (* (floor (/ a b)) b))))
        (insert "memcp-tests" "mp_pressure" '("id" "a" "b" "c" "d" "e" "f")
          (produceN 300000 (lambda (i) (list i
            (imod (* i 54321) 999983)
            (imod (* i 12347) 999979)
            (imod (* i 98765) 999961)
            (imod (* i 33331) 999953)
            (imod (* i 77773) 999931)
            (concat "val_" (imod (* i 13579) 99991))))))
        (rebuild)
        "ok")
    expect: {}

  # --- 3 queries on id to trigger index creation (threshold=2.0, +1.0 per query) ---

  - name: "MP: query 1 on id (Savings=1, no index yet)"
    sql: "SELECT id, a FROM `memcp-tests`.mp_pressure WHERE id = 100000"
    expect:
      rows: 1
      data:
        - id: 100000
          a: 192344

  - name: "MP: query 2 on id (Savings=2, triggers index build)"
    sql: "SELECT id, a FROM `memcp-tests`.mp_pressure WHERE id = 200000"
    expect:
      rows: 1
      data:
        - id: 200000
          a: 384688

  - name: "MP: query 3 on id (uses built index)"
    sql: "SELECT id, a FROM `memcp-tests`.mp_pressure WHERE id = 50000"
    expect:
      rows: 1
      data:
        - id: 50000
          a: 96172

  - name: "MP: stat before pressure (shards+indexes registered)"
    scm: (stat)
    expect: {}

  # --- Tier 1: persisted budget eviction (shards + indexes only) ---

  - name: "MP: set MaxPersistBytes to 1 (trigger persisted eviction)"
    scm: (settings "MaxPersistBytes" 1)
    expect: {}

  - name: "MP: stat after persisted pressure (shards+indexes evicted)"
    scm: (stat)
    expect: {}

  - name: "MP: select after persisted eviction (forces shard+index reload)"
    sql: "SELECT id, a, b FROM `memcp-tests`.mp_pressure WHERE id = 150000"
    expect:
      rows: 1
      data:
        - id: 150000
          a: 288516
          b: 88892

  - name: "MP: reset MaxPersistBytes to 0"
    scm: (settings "MaxPersistBytes" 0)
    expect: {}

  # --- Tier 2: total budget eviction (all types) ---

  - name: "MP: set MaxRamBytes to 1 (trigger total eviction)"
    scm: (settings "MaxRamBytes" 1)
    expect: {}

  - name: "MP: select after total eviction"
    sql: "SELECT id, a, b FROM `memcp-tests`.mp_pressure WHERE id = 150000"
    expect:
      rows: 1
      data:
        - id: 150000
          a: 288516
          b: 88892

  - name: "MP: reset MaxRamBytes to 0"
    scm: (settings "MaxRamBytes" 0)
    expect: {}

  # --- Tier 3: temp keytable + temp column eviction ---
  # GROUP BY creates a temp keytable (`.mp_pressure:a`) and computed temp columns on it.

  - name: "MP: GROUP BY creates temp keytable + computed columns"
    sql: "SELECT a, SUM(b) AS sb FROM `memcp-tests`.mp_pressure GROUP BY a ORDER BY a LIMIT 5"
    timeout: 300
    expect:
      rows: 5

  - name: "MP: stat after GROUP BY (keytables+temp columns registered)"
    scm: (stat)
    expect: {}

  - name: "MP: set MaxRamBytes to 1 (evict temp keytables + columns)"
    scm: (settings "MaxRamBytes" 1)
    expect: {}

  - name: "MP: stat after temp eviction"
    scm: (stat)
    expect: {}

  - name: "MP: GROUP BY still works after temp keytable eviction"
    sql: "SELECT a, SUM(b) AS sb FROM `memcp-tests`.mp_pressure GROUP BY a ORDER BY a LIMIT 3"
    timeout: 300
    expect:
      rows: 3

  - name: "MP: reset MaxRamBytes to 0 (final)"
    scm: (settings "MaxRamBytes" 0)
    expect: {}

  # --- Tier 4: persisted eviction + reload + GROUP BY (combined path) ---

  - name: "MP: set MaxPersistBytes to 1 (evict shards)"
    scm: (settings "MaxPersistBytes" 1)
    expect: {}

  - name: "MP: GROUP BY after shard eviction (forces reload + temp keytable)"
    sql: "SELECT a, COUNT(*) AS cnt FROM `memcp-tests`.mp_pressure GROUP BY a ORDER BY a LIMIT 3"
    timeout: 300
    expect:
      rows: 3

  - name: "MP: reset MaxPersistBytes to 0 (final)"
    scm: (settings "MaxPersistBytes" 0)
    expect: {}

  # --- Tier 5: explicit temp column via createcolumn + eviction ---

  - name: "MP: create temp computed column"
    scm: |
      (begin
        (createcolumn "memcp-tests" "mp_pressure" "tmp_sum" "any" '() '("temp" true)
          '("a" "b") (lambda (a b) (+ a b)))
        "ok")
    expect: {}

  - name: "MP: read from temp column"
    sql: "SELECT id, tmp_sum FROM `memcp-tests`.mp_pressure WHERE id = 100000 LIMIT 1"
    expect:
      rows: 1

  - name: "MP: set MaxRamBytes to 1 (evict temp column)"
    scm: (settings "MaxRamBytes" 1)
    expect: {}

  - name: "MP: stat after temp column eviction"
    scm: (stat)
    expect: {}

  - name: "MP: reset MaxRamBytes to 0 (after temp col eviction)"
    scm: (settings "MaxRamBytes" 0)
    expect: {}

  # --- Tier 6: DropTable cleans up temp keytable from cache ---

  - name: "MP: GROUP BY to create temp keytable for drop test"
    sql: "SELECT a, SUM(c) AS sc FROM `memcp-tests`.mp_pressure GROUP BY a ORDER BY a LIMIT 1"
    timeout: 300
    expect:
      rows: 1

  - name: "MP: drop table cleans up all cache entries"
    sql: "DROP TABLE IF EXISTS `memcp-tests`.mp_pressure"
    expect: {}

  - name: "MP: stat after drop (orphaned entries cleared)"
    scm: (stat)
    expect: {}

cleanup:
  - sql: "DROP TABLE IF EXISTS mp_pressure"
