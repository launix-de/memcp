# Performance tests for basic operations
# Run with: PERF_TEST=1 make test
# Calibrate with: PERF_TEST=1 PERF_CALIBRATE=1 make test (run ~10 times)
# Bisect with: PERF_TEST=1 PERF_NORECALIBRATE=1 make test
# Show query plans: PERF_TEST=1 PERF_EXPLAIN=1 make test
# Row counts auto-scale per-test to target 10-20s query time
# {rows} and {database} are template placeholders filled by the test runner

metadata:
  version: "1.0"
  description: "Performance tests: aggregation, joins, ordering"

test_cases:
  # COUNT aggregation with data generation
  - name: "Perf: COUNT"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT COUNT(*) AS cnt FROM perf_main"
    threshold_ms: 30000
    expect:
      rows: 1

  # SUM aggregation
  - name: "Perf: SUM"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT SUM(value) AS total FROM perf_main"
    threshold_ms: 30000
    expect:
      rows: 1

  # ORDER BY with LIMIT
  - name: "Perf: ORDER+LIMIT"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT id, value FROM perf_main ORDER BY value DESC LIMIT 100"
    threshold_ms: 30000
    expect:
      rows: 100

  # Full table scan with filter
  - name: "Perf: SCAN+FILTER"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT COUNT(*) AS cnt FROM perf_main WHERE value > 500000"
    threshold_ms: 30000
    expect:
      rows: 1

cleanup:
  - sql: "DROP TABLE IF EXISTS perf_main"
  - sql: "DROP TABLE IF EXISTS perf_small"
