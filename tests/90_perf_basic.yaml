# Performance tests for basic operations
# Run with: PERF_TEST=1 make test
# Calibrate with: PERF_TEST=1 PERF_CALIBRATE=1 make test (run ~10 times)
# Bisect with: PERF_TEST=1 PERF_NORECALIBRATE=1 make test
# Show query plans: PERF_TEST=1 PERF_EXPLAIN=1 make test
# Row counts auto-scale per-test to target 10-20s query time
# {rows} and {database} are template placeholders filled by the test runner

metadata:
  version: "1.0"
  description: "Performance tests: aggregation, joins, ordering"

test_cases:
  # COUNT aggregation with data generation
  - name: "Perf: COUNT"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT COUNT(*) AS cnt FROM perf_main"
    threshold_ms: 30000
    expect:
      rows: 1

  # SUM aggregation
  - name: "Perf: SUM"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT SUM(value) AS total FROM perf_main"
    threshold_ms: 30000
    expect:
      rows: 1

  # ORDER BY with LIMIT
  - name: "Perf: ORDER+LIMIT"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT id, value FROM perf_main ORDER BY value DESC LIMIT 100"
    threshold_ms: 30000
    expect:
      rows: 100

  # Full table scan with filter
  - name: "Perf: SCAN+FILTER"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT COUNT(*) AS cnt FROM perf_main WHERE value > 500000"
    threshold_ms: 30000
    expect:
      rows: 1

  # GROUP BY aggregation
  - name: "Perf: GROUP BY"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (* i 54) (* i 71) (concat "str_" i)))))
            (set cnt (insert "{database}" "perf_main" '("id" "category" "value" "name") rows))
            (rebuild)
            (set mem (memstats))
            (list cnt (mem "heap_alloc")))
    sql: "SELECT category % 100 AS cat, COUNT(*) AS cnt, SUM(value) AS total FROM perf_main GROUP BY category % 100"
    threshold_ms: 30000
    expect:
      rows: 50

  # Equality join: dimension table drives scan with equality boundary on index
  # 100 dimension rows x {rows}/100 matches each = {rows} total joined rows
  - name: "Perf: EQUI JOIN"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - sql: "DROP TABLE IF EXISTS `perf_dim`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - sql: "CREATE TABLE `perf_dim` (cat_id INT PRIMARY KEY, label TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (- i (* 100 (floor (/ i 100)))) (* i 71) (concat "str_" i)))))
            (insert "{database}" "perf_main" '("id" "category" "value" "name") rows)
            (set dims (map (produceN 100) (lambda (i) (list i (concat "cat_" i)))))
            (insert "{database}" "perf_dim" '("cat_id" "label") dims)
            (rebuild)
            "ok")
    sql: "SELECT d.label, m.id FROM perf_dim d JOIN perf_main m ON m.category = d.cat_id"
    threshold_ms: 30000

  # Range join: dimension table drives scan with range boundaries on index
  # 20 range buckets covering all values = {rows} total joined rows
  - name: "Perf: RANGE JOIN"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - sql: "DROP TABLE IF EXISTS `perf_ranges`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - sql: "CREATE TABLE `perf_ranges` (range_id INT PRIMARY KEY, low_val INT, high_val INT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (- i (* 100 (floor (/ i 100)))) (* i 71) (concat "str_" i)))))
            (insert "{database}" "perf_main" '("id" "category" "value" "name") rows)
            (set ranges (map (produceN 20) (lambda (i) (list i (* i (/ (* {rows} 71) 20)) (* (+ i 1) (/ (* {rows} 71) 20))))))
            (insert "{database}" "perf_ranges" '("range_id" "low_val" "high_val") ranges)
            (rebuild)
            "ok")
    sql: "SELECT r.range_id, m.id FROM perf_ranges r JOIN perf_main m ON m.value >= r.low_val AND m.value < r.high_val"
    threshold_ms: 30000

  # Matrix multiplication: C = A*B via equi join
  # {rows} = matrix dimension, each matrix has {rows}*{rows} entries
  # Total work: O({rows}^3) â€” auto-scaler will find dim ~100-300
  # GROUP BY on joins not yet supported; raw join is the dominant cost anyway
  - name: "Perf: MATRIX MULT"
    setup:
      - sql: "DROP TABLE IF EXISTS `mat_a`"
      - sql: "DROP TABLE IF EXISTS `mat_b`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `mat_a` (r INT, c INT, v INT)"
      - sql: "CREATE TABLE `mat_b` (r INT, c INT, v INT)"
      - scm: |
          (begin
            (set dim {rows})
            (set n (* dim dim))
            (set a (map (produceN n) (lambda (i) (list (floor (/ i dim)) (- i (* dim (floor (/ i dim)))) (+ 1 i)))))
            (insert "{database}" "mat_a" '("r" "c" "v") a)
            (set b (map (produceN n) (lambda (i) (list (floor (/ i dim)) (- i (* dim (floor (/ i dim)))) (+ 1 (* 3 i))))))
            (insert "{database}" "mat_b" '("r" "c" "v") b)
            (rebuild)
            "ok")
    sql: "SELECT a.r, b.c, a.v * b.v AS v FROM mat_a a JOIN mat_b b ON a.c = b.r"
    threshold_ms: 30000

  # Delta+main index join: 90% main + 10% delta on inner side
  # Dimension table drives equi-join; inner side uses index with streaming merge
  - name: "Perf: DELTA JOIN"
    setup:
      - sql: "DROP TABLE IF EXISTS `perf_main`"
      - sql: "DROP TABLE IF EXISTS `perf_dim`"
      - scm: "(rebuild)"
      - sql: "CREATE TABLE `perf_main` (id INT PRIMARY KEY, category INT, value INT, name TEXT)"
      - sql: "CREATE TABLE `perf_dim` (cat_id INT PRIMARY KEY, label TEXT)"
      - scm: |
          (begin
            (set rows (map (produceN {rows}) (lambda (i) (list i (- i (* 100 (floor (/ i 100)))) (* i 71) (concat "str_" i)))))
            (insert "{database}" "perf_main" '("id" "category" "value" "name") rows)
            (set dims (map (produceN 100) (lambda (i) (list i (concat "cat_" i)))))
            (insert "{database}" "perf_dim" '("cat_id" "label") dims)
            (rebuild)
            (set delta_n (floor (/ {rows} 10)))
            (set delta (map (produceN delta_n) (lambda (i) (list (+ i {rows}) (- i (* 100 (floor (/ i 100)))) (* (+ i {rows}) 71) (concat "delta_" i)))))
            (insert "{database}" "perf_main" '("id" "category" "value" "name") delta)
            "ok")
    sql: "SELECT d.label, m.id FROM perf_dim d JOIN perf_main m ON m.category = d.cat_id"
    threshold_ms: 30000

cleanup:
  - sql: "DROP TABLE IF EXISTS perf_main"
  - sql: "DROP TABLE IF EXISTS perf_dim"
  - sql: "DROP TABLE IF EXISTS perf_ranges"
  - sql: "DROP TABLE IF EXISTS mat_a"
  - sql: "DROP TABLE IF EXISTS mat_b"
