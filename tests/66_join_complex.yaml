# Complex JOIN coverage
# Targets scan.go join paths, partition.go iterateShards during join,
# index.go iterateIndex, and analyzer.go extractBoundaries.

metadata:
  version: "1.0"
  description: "JOIN variations: multi-table, self-join, NULLs, filters"

setup:
  - sql: "DROP TABLE IF EXISTS jc_orders"
  - sql: "DROP TABLE IF EXISTS jc_customers"
  - sql: "DROP TABLE IF EXISTS jc_products"
  - sql: "DROP TABLE IF EXISTS jc_items"
  - sql: |
      CREATE TABLE jc_customers (
        cid INT, name VARCHAR(30), region VARCHAR(20)
      )
  - sql: |
      INSERT INTO jc_customers VALUES
        (1, 'Alice', 'North'), (2, 'Bob', 'South'),
        (3, 'Carol', 'North'), (4, 'Dave', NULL)
  - sql: |
      CREATE TABLE jc_orders (
        oid INT, cid INT, total DOUBLE, status VARCHAR(10)
      )
  - sql: |
      INSERT INTO jc_orders VALUES
        (101, 1, 250.00, 'shipped'),
        (102, 1, 100.00, 'pending'),
        (103, 2, 500.00, 'shipped'),
        (104, 3, 75.00, 'cancelled'),
        (105, 2, 300.00, 'shipped'),
        (106, NULL, 50.00, 'pending')
  - sql: |
      CREATE TABLE jc_products (
        pid INT, pname VARCHAR(30), price DOUBLE
      )
  - sql: |
      INSERT INTO jc_products VALUES
        (1, 'Widget', 25.00), (2, 'Gadget', 50.00), (3, 'Doohickey', 10.00)
  - sql: |
      CREATE TABLE jc_items (
        oid INT, pid INT, qty INT
      )
  - sql: |
      INSERT INTO jc_items VALUES
        (101, 1, 10), (101, 2, 1), (102, 3, 10),
        (103, 2, 10), (104, 1, 3), (105, 1, 4), (105, 3, 6)

test_cases:

  # === Basic INNER JOIN ===

  - name: "Simple two-table join"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      ORDER BY o.oid
    expect:
      rows: 5

  - name: "JOIN with WHERE"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      WHERE o.status = 'shipped'
      ORDER BY o.total DESC
    expect:
      rows: 3

  - name: "JOIN with WHERE on both tables"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      WHERE o.status = 'shipped' AND c.region = 'South'
      ORDER BY o.total DESC
    expect:
      rows: 2

  # === Three-table JOIN ===

  - name: "Three-table join: orders with items and products"
    sql: |
      SELECT c.name, i.qty, p.pname
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      JOIN jc_items i ON o.oid = i.oid
      JOIN jc_products p ON i.pid = p.pid
      WHERE o.status = 'shipped'
      ORDER BY c.name, p.pname
    expect:
      rows: 5

  - name: "Four-table join: line item totals"
    sql: |
      SELECT c.name, p.pname, i.qty, p.price
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      JOIN jc_items i ON o.oid = i.oid
      JOIN jc_products p ON i.pid = p.pid
      WHERE c.name = 'Alice'
      ORDER BY p.pname
    expect:
      rows: 3

  # === Self-join ===

  - name: "Self-join: customers in same region"
    sql: |
      SELECT a.name AS name1, b.name AS name2
      FROM jc_customers a
      JOIN jc_customers b ON a.region = b.region
      WHERE a.cid < b.cid
      ORDER BY a.name, b.name
    expect:
      rows: 1
      data:
        - name1: "Alice"
          name2: "Carol"

  # === JOIN with NULL join key ===

  - name: "NULL join key excluded from INNER JOIN"
    sql: |
      SELECT o.oid, c.name
      FROM jc_orders o
      JOIN jc_customers c ON o.cid = c.cid
    expect:
      rows: 5

  # === JOIN + ORDER BY + LIMIT ===

  - name: "JOIN with ORDER BY DESC"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      ORDER BY o.total DESC
    expect:
      rows: 5

  # === JOIN with subquery filter ===

  - name: "JOIN filtered by IN subquery"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      WHERE c.cid IN (SELECT cid FROM jc_customers WHERE region = 'North')
      ORDER BY o.total
    expect:
      rows: 3

  # === JOIN with various conditions ===

  - name: "JOIN with inequality condition"
    sql: |
      SELECT c.name, o.total
      FROM jc_customers c
      JOIN jc_orders o ON c.cid = o.cid
      WHERE o.total > 200
      ORDER BY o.total DESC
    expect:
      rows: 3

cleanup:
  - sql: "DROP TABLE IF EXISTS jc_items"
  - sql: "DROP TABLE IF EXISTS jc_products"
  - sql: "DROP TABLE IF EXISTS jc_orders"
  - sql: "DROP TABLE IF EXISTS jc_customers"
