byobu ctrl+f2 split, f7 scroll back

MMap
----
import "https://github.com/edsrzf/mmap-go/blob/main/mmap.go"
mmap.Map(file, RDWR, 0) // oder RDONLY
// available functions: Flush, Unmap
// ist dann ein byte[]

TODO
----
 - session-local storage for mysql session state (variables, current schema)
 - per-table persistency settings
 - temptable -> createtemptable(columns)
 - queryplan builder:
 	-> turn all subqueries into LEFT JOINs
	-> merge all join'd tables with the same condition
	-> join order
	-> scan generation
 - scan_star (schema table-list join-column-list filter-list map-list map reduce neutral (equi-joins with cached last-index positions)
 - scan -> only "go" those shards that have the value range within (in an optimized data structure because there can be thousands of shards)
 - line numbers and filenames -> wrapper for []Scmer that has to run .Verify??? SYMBOL [debug]
 - docker hub upload
 - mysql importer
 - plugin concept e.g. for AIs (they will declare new scheme functions)
 - transactions: every delete+insert has a optional txid (or 0 if committed); rebuild only rebuilds up to the last committed insert-item; scans are relative to a txid where items with a non-matching txid are ignored
 - primary key generator
 - system.grant, system.user.all -> allow access for some databases
 - tables stored in a table? (StorageSCMER)
 - periodic (rebuild)
 - plugins: go build --buildmode shared -linkshared std in a subfolder


Cache strategy
--------------
 - Cache objects: parent list, identifier (concurrent map!), created-at, last-used, size
 - delete-list ordered by age*size -> delete those items with highest number first

LISP processor Mach 2
---------------------
every value consists of two uint64
a) descriptor (8 bit self type descriptor, 8 bit payload type descriptor, 8 bit env-depth of next, 32 bit next-index)
b) payload value: uint64, int64, double, listidx, functionptr
types: empty list, list-head

also, there is an execution environment (each exenv is a heapsize, heap[heapsize]value, parent *exenv)
the env-depth tells the interpreter to look up next-values from the parent env
when the heap is full, a new heap is opened
every thread runs in its own exec-env; a thread can pre-allocate a fixed size heap for fast access
heaps are removed in whole pieces

max integer storable in doubles: 9007199254740992 (9 Peta)
