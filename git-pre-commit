#!/bin/bash
#
# MemCP Pre-commit Hook
# Runs SQL tests before allowing commits using a single MemCP instance
#

echo "üîç Running MemCP pre-commit tests..."

# Global state for reliable cleanup
did_cleanup=0
active_pids=()

# Build memcp to ensure latest changes are included
echo "üî® Building memcp..."
build_flags=""
if [ "${MEMCP_COVERAGE:-}" = "1" ]; then
    build_flags="-cover"
    export GOCOVERDIR="${MEMCP_COVERDIR:-/tmp/memcp-coverage}"
    rm -rf "$GOCOVERDIR"
    mkdir -p "$GOCOVERDIR"
    echo "üìä Coverage mode enabled (GOCOVERDIR=$GOCOVERDIR)"
fi
if ! go build $build_flags -o memcp; then
    echo "‚ùå Build failed, commit aborted"
    exit 1
fi

# Find all numbered test files (01_*.yaml, 02_*.yaml, etc.)
test_files=$(find tests/ -name "[0-9][0-9]_*.yaml" | sort)

if [ -z "$test_files" ]; then
    echo "‚ùå No test files found in tests/ directory"
    exit 1
fi

echo "Found test files:"
echo "$test_files"
echo ""

test_port=4480
godebug="$GODEBUG"
if [[ "$godebug" != *"invalidptr="* ]]; then
  if [ -n "$godebug" ]; then
    godebug="${godebug},invalidptr=0"
  else
    godebug="invalidptr=0"
  fi
fi
run_memcp_forever() {
  trap 'kill $memcp_pid 2>/dev/null; exit 0' TERM INT
  while true; do
    echo "üöÄ (re)Starting MemCP on port $test_port..."
    pkill -f "memcp.*--api-port=$test_port" || true
    sleep 1
    GODEBUG="$godebug" ./memcp -data "/tmp/memcp-pre-commit-tests" --api-port=$test_port --mysql-port=$((test_port + 1000)) --disable-mysql lib/main.scm < "$fifo_path" >> /tmp/memcp-test.log 2>&1 &
    memcp_pid=$!
    # wait for process to exit; test loop will poll readiness
    wait $memcp_pid
    echo "‚ö†Ô∏è  MemCP exited (code=$?). Restarting..."
    sleep 0.5
  done
}

# Prepare data dir and logfile once outside the loop
rm -rf /tmp/memcp-pre-commit-tests || true
echo -n > /tmp/memcp-test.log

# Create FIFO to keep stdin open across restarts
fifo_path="/tmp/memcp-stdin-$test_port"
rm -f "$fifo_path" 2>/dev/null || true
mkfifo "$fifo_path"
# Keep writer end open for the lifetime of this script
exec 3<> "$fifo_path"

# Start supervisor loop
run_memcp_forever &
supervisor_pid=$!

# Wait until ready once
echo "‚è≥ Waiting for MemCP to be ready..."
for i in {1..60}; do
  if curl -s "http://localhost:$test_port" >/dev/null 2>&1; then
    echo "‚úÖ MemCP is ready!"
    break
  fi
  sleep 1
done

cleanup() {
  # Make cleanup idempotent
  if [ "$did_cleanup" -eq 1 ]; then return; fi
  did_cleanup=1
  echo ""; echo "üõë Stopping MemCP..."
  # Stop any active test jobs we spawned
  if [ ${#active_pids[@]} -gt 0 ]; then
    kill "${active_pids[@]}" 2>/dev/null || true
  fi
  # Also stop any other background jobs (best-effort)
  for pid in $(jobs -p 2>/dev/null); do
    kill "$pid" 2>/dev/null || true
  done
  kill $supervisor_pid 2>/dev/null || true
  # Also kill an active memcp if still running
  pkill -f "memcp.*--api-port=$test_port" 2>/dev/null || true
  # Close and remove FIFO
  exec 3>&-
  rm -f "$fifo_path" 2>/dev/null || true
  # Remove temp directory if created
  if [ -n "$tmpdir" ] && [ -d "$tmpdir" ]; then
    rm -rf "$tmpdir" 2>/dev/null || true
  fi
  echo "‚úÖ MemCP stopped"
}
trap cleanup EXIT
# Handle Ctrl+C and termination signals
trap 'echo; echo "‚úã Interrupted"; cleanup; exit 130' INT
trap 'echo; echo "‚úã Terminated"; cleanup; exit 143' TERM
trap 'cleanup; exit 129' HUP

echo "üß™ Running SQL tests using single MemCP instance (parallel where safe)..."

all_passed=true
failed_files=""

# Split tests: those that contain SHUTDOWN (disruptive) run sequentially; others in parallel
parallel_tests=""
sequential_tests=""
for tf in $test_files; do
  if grep -q "SHUTDOWN" "$tf"; then
    sequential_tests="$sequential_tests $tf"
  else
    parallel_tests="$parallel_tests $tf"
  fi
done

# Limit concurrency to number of processors, cap at 8
max_jobs=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)
if [ "$max_jobs" -gt 8 ]; then max_jobs=8; fi

tmpdir=$(mktemp -d)
lockfile="/tmp/memcp-print.lock"

run_one() {
  local tf="$1"
  local out="$2"
  local statusf="$3"
  # Wait for readiness before starting
  for i in {1..30}; do
    if curl -s "http://localhost:$test_port" >/dev/null 2>&1; then break; fi
    sleep 1
  done
  python3 run_sql_tests.py "$tf" $test_port --connect-only > "$out" 2>&1
  rc=$?
  # Determine status by exit code (0 => OK, nonzero => FAIL)
  if [ $rc -eq 0 ]; then echo OK > "$statusf"; else echo FAIL > "$statusf"; fi
  # Critical section: print output of this test
  {
    flock -x 9
    cat "$out"
    echo ""
  } 9>>"$lockfile"
}

# Run parallel-safe tests (track only test PIDs)
for tf in $parallel_tests; do
  out="$tmpdir/$(basename "$tf").out"
  statusf="$tmpdir/$(basename "$tf").status"
  run_one "$tf" "$out" "$statusf" &
  active_pids+=("$!")
  # Concurrency gate: wait for the oldest test PID when at limit
  while [ ${#active_pids[@]} -ge $max_jobs ]; do
    wait "${active_pids[0]}"
    active_pids=("${active_pids[@]:1}")
  done
done
# Wait for remaining test jobs (ignore supervisor)
for pid in "${active_pids[@]}"; do
  wait "$pid"
done

# Run disruptive tests sequentially
for tf in $sequential_tests; do
  out="$tmpdir/$(basename "$tf").out"
  statusf="$tmpdir/$(basename "$tf").status"
  run_one "$tf" "$out" "$statusf"
done

# Stop supervisor and memcp now that all tests are done
kill $supervisor_pid 2>/dev/null || true
pkill -f "memcp.*--api-port=$test_port" 2>/dev/null || true

# Collect results in test file order
for tf in $test_files; do
  statusf="$tmpdir/$(basename "$tf").status"
  if [ -f "$statusf" ] && grep -q OK "$statusf"; then :; else
    all_passed=false
    failed_files="$failed_files $tf"
  fi
done

# Print detailed logs for failed test files again at the end
if [ "$all_passed" != true ]; then
  echo ""
  echo "üîé Detailed failure logs:"
  for tf in $test_files; do
    statusf="$tmpdir/$(basename "$tf").status"
    if [ -f "$statusf" ] && grep -q OK "$statusf"; then
      continue
    fi
    echo ""
    echo "===== $(basename "$tf") ====="
    out="$tmpdir/$(basename "$tf").out"
    if [ -f "$out" ]; then
      cat "$out"
    else
      echo "(no output captured)"
    fi
    echo "===== end $(basename "$tf") ====="
  done
  echo ""
fi

rm -rf "$tmpdir"

# Generate coverage report if coverage mode was enabled
if [ "${MEMCP_COVERAGE:-}" = "1" ] && [ -d "$GOCOVERDIR" ]; then
    echo ""
    echo "üìä Generating Go coverage report..."
    if ls "$GOCOVERDIR"/*.* >/dev/null 2>&1; then
        go tool covdata textfmt -i="$GOCOVERDIR" -o="$GOCOVERDIR/coverage.out" 2>/dev/null
        if [ -f "$GOCOVERDIR/coverage.out" ]; then
            go tool cover -func="$GOCOVERDIR/coverage.out" | tail -1
            echo "   Full report: go tool cover -html=$GOCOVERDIR/coverage.out"
        fi
    else
        echo "   ‚ö†Ô∏è  No coverage data collected"
    fi
fi

if [ "$all_passed" = true ]; then
    echo "üéâ All tests passed, commit allowed"
    exit 0
else
    echo "‚ùå Some tests failed, commit aborted"
    echo ""
    echo "Failed test files:$failed_files"
    echo ""
    echo "You can run individual test files manually with:"
    echo "  python3 run_sql_tests.py <test_file.yaml> $test_port --connect-only"
    echo "  (Make sure to start MemCP first: ./memcp --api-port=$test_port --disable-mysql)"
    exit 1
fi
