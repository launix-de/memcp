#!/bin/bash
#
# MemCP Pre-commit Hook
# Runs SQL tests before allowing commits using a single MemCP instance
#

echo "🔍 Running MemCP pre-commit tests..."

# Global state for reliable cleanup
did_cleanup=0
active_pids=()

# Build memcp to ensure latest changes are included
echo "🔨 Building memcp..."
if ! go build -o memcp; then
    echo "❌ Build failed, commit aborted"
    exit 1
fi

# Find all numbered test files (01_*.yaml, 02_*.yaml, etc.)
test_files=$(find tests/ -name "[0-9][0-9]_*.yaml" | sort)

if [ -z "$test_files" ]; then
    echo "❌ No test files found in tests/ directory"
    exit 1
fi

echo "Found test files:"
echo "$test_files"
echo ""

test_port=4400
run_memcp_forever() {
  while true; do
    echo "🚀 (re)Starting MemCP on port $test_port..."
    pkill -f "memcp.*--api-port=$test_port" || true
    sleep 1
    ./memcp -data "/tmp/memcp-pre-commit-tests" --api-port=$test_port --mysql-port=$((test_port + 1000)) --disable-mysql lib/main.scm < "$fifo_path" >> /tmp/memcp-test.log 2>&1 &
    memcp_pid=$!
    # wait for process to exit; test loop will poll readiness
    wait $memcp_pid
    echo "⚠️  MemCP exited (code=$?). Restarting..."
    sleep 0.5
  done
}

# Prepare data dir and logfile once outside the loop
rm -rf /tmp/memcp-pre-commit-tests || true
echo -n > /tmp/memcp-test.log

# Create FIFO to keep stdin open across restarts
fifo_path="/tmp/memcp-stdin-$test_port"
rm -f "$fifo_path" 2>/dev/null || true
mkfifo "$fifo_path"
# Keep writer end open for the lifetime of this script
exec 3<> "$fifo_path"

# Start supervisor loop
run_memcp_forever &
supervisor_pid=$!

# Wait until ready once
echo "⏳ Waiting for MemCP to be ready..."
for i in {1..60}; do
  if curl -s "http://localhost:$test_port" >/dev/null 2>&1; then
    echo "✅ MemCP is ready!"
    break
  fi
  sleep 1
done

cleanup() {
  # Make cleanup idempotent
  if [ "$did_cleanup" -eq 1 ]; then return; fi
  did_cleanup=1
  echo ""; echo "🛑 Stopping MemCP..."
  # Stop any active test jobs we spawned
  if [ ${#active_pids[@]} -gt 0 ]; then
    kill "${active_pids[@]}" 2>/dev/null || true
  fi
  # Also stop any other background jobs (best-effort)
  for pid in $(jobs -p 2>/dev/null); do
    kill "$pid" 2>/dev/null || true
  done
  kill $supervisor_pid 2>/dev/null || true
  # Also kill an active memcp if still running
  pkill -f "memcp.*--api-port=$test_port" 2>/dev/null || true
  # Close and remove FIFO
  exec 3>&-
  rm -f "$fifo_path" 2>/dev/null || true
  # Remove temp directory if created
  if [ -n "$tmpdir" ] && [ -d "$tmpdir" ]; then
    rm -rf "$tmpdir" 2>/dev/null || true
  fi
  echo "✅ MemCP stopped"
}
trap cleanup EXIT
# Handle Ctrl+C and termination signals
trap 'echo; echo "✋ Interrupted"; cleanup; exit 130' INT
trap 'echo; echo "✋ Terminated"; cleanup; exit 143' TERM
trap 'cleanup; exit 129' HUP

echo "🧪 Running SQL tests using single MemCP instance (parallel where safe)..."

all_passed=true
failed_files=""

# Split tests: those that contain SHUTDOWN (disruptive) run sequentially; others in parallel
parallel_tests=""
sequential_tests=""
for tf in $test_files; do
  if grep -q "SHUTDOWN" "$tf"; then
    sequential_tests="$sequential_tests $tf"
  else
    parallel_tests="$parallel_tests $tf"
  fi
done

# Limit concurrency to number of processors, cap at 8
max_jobs=$(getconf _NPROCESSORS_ONLN 2>/dev/null || echo 4)
if [ "$max_jobs" -gt 8 ]; then max_jobs=8; fi

tmpdir=$(mktemp -d)
lockfile="/tmp/memcp-print.lock"

run_one() {
  local tf="$1"
  local out="$2"
  local statusf="$3"
  # Wait for readiness before starting
  for i in {1..30}; do
    if curl -s "http://localhost:$test_port" >/dev/null 2>&1; then break; fi
    sleep 1
  done
  python3 run_sql_tests.py "$tf" $test_port --connect-only > "$out" 2>&1
  rc=$?
  # Determine status by exit code (0 => OK, nonzero => FAIL)
  if [ $rc -eq 0 ]; then echo OK > "$statusf"; else echo FAIL > "$statusf"; fi
  # Critical section: print output of this test
  {
    flock -x 9
    cat "$out"
    echo ""
  } 9>>"$lockfile"
}

# Run parallel-safe tests (track only test PIDs)
for tf in $parallel_tests; do
  out="$tmpdir/$(basename "$tf").out"
  statusf="$tmpdir/$(basename "$tf").status"
  run_one "$tf" "$out" "$statusf" &
  active_pids+=("$!")
  # Concurrency gate: wait for the oldest test PID when at limit
  while [ ${#active_pids[@]} -ge $max_jobs ]; do
    wait "${active_pids[0]}"
    active_pids=("${active_pids[@]:1}")
  done
done
# Wait for remaining test jobs (ignore supervisor)
for pid in "${active_pids[@]}"; do
  wait "$pid"
done

# Run disruptive tests sequentially
for tf in $sequential_tests; do
  out="$tmpdir/$(basename "$tf").out"
  statusf="$tmpdir/$(basename "$tf").status"
  run_one "$tf" "$out" "$statusf"
done

# Stop supervisor and memcp now that all tests are done
kill $supervisor_pid 2>/dev/null || true
pkill -f "memcp.*--api-port=$test_port" 2>/dev/null || true

# Collect results in test file order
for tf in $test_files; do
  statusf="$tmpdir/$(basename "$tf").status"
  if [ -f "$statusf" ] && grep -q OK "$statusf"; then :; else
    all_passed=false
    failed_files="$failed_files $tf"
  fi
done

# Print detailed logs for failed test files again at the end
if [ "$all_passed" != true ]; then
  echo ""
  echo "🔎 Detailed failure logs:"
  for tf in $test_files; do
    statusf="$tmpdir/$(basename "$tf").status"
    if [ -f "$statusf" ] && grep -q OK "$statusf"; then
      continue
    fi
    echo ""
    echo "===== $(basename "$tf") ====="
    out="$tmpdir/$(basename "$tf").out"
    if [ -f "$out" ]; then
      cat "$out"
    else
      echo "(no output captured)"
    fi
    echo "===== end $(basename "$tf") ====="
  done
  echo ""
fi

rm -rf "$tmpdir"

if [ "$all_passed" = true ]; then
    echo "🎉 All tests passed, commit allowed"
    exit 0
else
    echo "❌ Some tests failed, commit aborted"
    echo ""
    echo "Failed test files:$failed_files"
    echo ""
    echo "You can run individual test files manually with:"
    echo "  python3 run_sql_tests.py <test_file.yaml> $test_port --connect-only"
    echo "  (Make sure to start MemCP first: ./memcp --api-port=$test_port --disable-mysql)"
    exit 1
fi
